#!/usr/bin/env node
// Praetorius CLI — wizard + generate (with PDF page-follow support)

import { Command } from 'commander';
import pc from 'picocolors';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import pkg from 'enquirer';
const { prompt } = pkg;
import Ajv from 'ajv';


/* ------------------ templates FIRST (avoid TDZ) ------------------ */
const STARTER_CSS = `/* Praetorius Works Console — minimal CSS seed (merge with your global/page CSS) */
#works-console .btn{padding:.4rem .7rem;border:1px solid var(--line,rgba(255,255,255,.18));border-radius:.6rem;background:transparent}
#works-console .line{opacity:.92;transition:opacity .2s}
#works-console .line.muted{opacity:.62}
#works-console .actions{display:flex;gap:.6rem;margin:.25rem 0 .6rem}
#works-console .toast{position:sticky;bottom:.5rem;align-self:flex-end;padding:.5rem .7rem;border-radius:.6rem;background:rgba(0,0,0,.7);backdrop-filter:blur(6px)}
`;

const STARTER_JS_NOTE = `/** Praetorius Works Console — starter v0
 * This is a seed file. The wizard-driven flow uses:
 *   - .prae/works.json  (your data)
 *   - praetorius generate  (to emit dist/script.js from data)
 */`;

const STARTER_JS = `${STARTER_JS_NOTE}
(function(){
  const works = [
    {
      id: 1,
      slug: 'soundnoisemusic',
      title: 'WORK 1 — String Quartet No. 2 “SOUNDNOISEMUSIC”',
      one: 'A through-composed/indeterminate quartet...',
      cues: [{ label: '@10:30', t: 630 }],
      audio: 'https://cdn.jsdelivr.net/gh/cbassuarez/website-blog/audio/SSS_soundnoisemusic_audio.mp3',
      pdf:   'https://cdn.jsdelivr.net/gh/cbassuarez/website-blog/STRING%20QUARTET%20NO.%202%20_soundnoisemusic_%20-%20Score-min.pdf'
    }
  ];
  window.PRAE = window.PRAE || {};
  window.PRAE.works = works;
  console.log('[prae] starter loaded: 1 work (edit script.js or use "praetorius add" + "praetorius generate").');
})();
`;

const STARTER_README = `Praetorius CLI starter
======================

Quick paths:

1) Old-school (manual)
   - Use "praetorius init" to get a seed script.js/styles.css
   - Paste script.js in a Squarespace Code block
   - Paste styles.css into Page/Site CSS

2) Wizard (recommended)
   - Run "praetorius add" to enter works interactively (stores in .prae/works.json)
   - Run "praetorius generate" to emit dist/script.js + dist/styles.css
   - Paste dist/script.js into your Code block; add dist/styles.css to page/site CSS
`;

/* --- script generator template (turns DB into paste-ready JS) --- */
function renderScriptFromDb(db, opts = {}) {
  const min = !!opts.minify;
  const worksArr = (db.works || []).map(w => ({
    id: w.id,
    slug: w.slug,
    title: w.title,
    one: w.one,
    cues: w.cues || [],
    pdf: w.pdf || null,
    audio: w.audio || null,
    audioId: `wc-a${w.id}`
  }));

  // Build page-follow maps keyed by slug (only for works that provide "score")
  const pf = {};
  for (const w of db.works || []) {
    if (w.score && (w.score.pdfStartPage || (w.score.pageMap && w.score.pageMap.length))) {
      pf[w.slug] = {
        pdfStartPage: Number.isInteger(w.score.pdfStartPage) ? w.score.pdfStartPage : 1,
        mediaOffsetSec: Number.isInteger(w.score.mediaOffsetSec) ? w.score.mediaOffsetSec : 0,
        pageMap: (w.score.pageMap || []).map(row => ({
          at: row.at,                 // mm:ss string or integer seconds; main.js can parse both
          page: row.page
        }))
      };
      if (Number.isInteger(w.score.pdfDelta)) {
        pf[w.slug].pdfDelta = w.score.pdfDelta; // optional override hook your console already supports
      }
    }
  }

 const serializedWorks = JSON.stringify(worksArr, null, min ? 0 : 2);
  const serializedPF    = JSON.stringify(pf, null,   min ? 0 : 2);

  return `/** AUTO-GENERATED by praetorius generate
 * Paste into a Squarespace Code block, or host as an external JS file.
 * Source data: .prae/works.json
 */
(function(){
  var works = ${serializedWorks};

  // Ensure matching <audio> tags exist and carry data-audio attributes.
  function ensureAudioTags() {
    works.forEach(function(w){
      if(!w.audio) return;
      var id = w.audioId || ('wc-a' + String(w.id||'').trim());
      if(!id) return;
      var a = document.getElementById(id);
      if(!a){
        a = document.createElement('audio');
        a.id = id;
        a.preload = 'none';
        a.setAttribute('playsinline','');
        a.setAttribute('data-audio', w.audio);
        var host = document.querySelector('#works-console') || document.body;
        host.appendChild(a);
      } else {
        a.setAttribute('data-audio', w.audio);
      }
    });
  }

  var worksById = {};
  works.forEach(function(w){ worksById[w.id] = w; });

  // Emit page-follow maps: picked up by main.js via
  // const pageFollowMaps = (window.PRAE && window.PRAE.pageFollowMaps) || { ...fallback... };
  var pageFollowMaps = ${serializedPF};

  window.PRAE = window.PRAE || {};
  window.PRAE.works = works;
  window.PRAE.worksById = worksById;
  window.PRAE.pageFollowMaps = pageFollowMaps;
  window.PRAE.ensureAudioTags = ensureAudioTags;
  // Optional theme hint from config (non-authoritative; UI can ignore)
  window.PRAE.config = window.PRAE.config || { theme: ${JSON.stringify((opts.theme === 'light') ? 'light' : 'dark')} };

  try { ensureAudioTags(); } catch(_) {}
  console.log('[prae] loaded', works.length, 'works; page-follow maps:', Object.keys(pageFollowMaps).length);
})();
`;
}

/* ------------------ schema + helpers ------------------ */
// Config schema (light) – theme + output flags
const DEFAULT_CONFIG = Object.freeze({
  theme: 'dark',                 // "light" | "dark"
  output: { minify: false, embed: false }
});

const WORKS_SCHEMA = {
  type: 'object',
  additionalProperties: false,
  required: ['version', 'works'],
  properties: {
    version: { type: 'integer' },
    works: {
      type: 'array',
      items: {
        type: 'object',
        additionalProperties: false,
        required: ['id','slug','title','one'],
        properties: {
          id:    { type: 'integer', minimum: 1 },
          slug:  { type: 'string', minLength: 1 },
          title: { type: 'string', minLength: 1 },
          one:   { type: 'string', minLength: 1 },
          audio: { type: ['string','null'] },
          pdf:   { type: ['string','null'] },
          cues: {
            type: 'array',
            items: {
              type: 'object',
              additionalProperties: false,
              required: ['label','t'],
              properties: {
                label: { type: 'string' },
                t:     { type: 'integer', minimum: 0 }
              }
            }
          },
          // NEW: score/page-follow block (optional)
          score: {
            type: 'object',
            additionalProperties: false,
            required: [],
            properties: {
              pdfStartPage:   { type: 'integer', minimum: 1 },
              mediaOffsetSec: { type: 'integer' },                // can be negative
              pdfDelta:       { type: 'integer' },                // optional tweak your console supports
              pageMap: {
                type: 'array',
                items: {
                  type: 'object',
                  additionalProperties: false,
                  required: ['at','page'],
                  properties: {
                    // allow both "mm:ss" strings and integer seconds
                    at: { anyOf: [{ type: 'string', minLength: 1 }, { type: 'integer', minimum: 0 }] },
                    page: { type: 'integer', minimum: 1 }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);

function cwdRel(p) { return path.relative(process.cwd(), p) || '.'; }
function slugify(s) {
  return (s||'').toLowerCase()
    .replace(/[“”"]/g,'')
    .replace(/[’']/g,'')
    .replace(/[^a-z0-9]+/g,'-')
    .replace(/^-+|-+$/g,'')
    .replace(/--+/g,'-') || 'work';
}
function parseTimeToSec(input) {
  if (!input) return 0;
  const s = String(input).trim();
  if (/^\d+$/.test(s)) return parseInt(s,10);
  const m = s.match(/^(\d+):([0-5]?\d)$/);
  if (m) return parseInt(m[1],10)*60 + parseInt(m[2],10);
  return 0;
}

/* ------------------ DB I/O ------------------ */
const DB_DIR  = path.resolve(process.cwd(), '.prae');
const DB_PATH = path.join(DB_DIR, 'works.json');
const CONFIG_DIR  = DB_DIR; // colocate
const CONFIG_PATH = path.join(CONFIG_DIR, 'config.json');

function readJsonSafe(p, fallback) {
  try { return JSON.parse(fs.readFileSync(p, 'utf8')); }
  catch { return fallback; }
}

// Atomic write with .bak (POSIX rename is atomic within same dir)
function atomicWriteFile(filePath, contents) {
  const dir = path.dirname(filePath);
  const base = path.basename(filePath);
  const tmp = path.join(dir, `.${base}.${process.pid}.${Date.now()}.tmp`);
  // backup existing
  if (fs.existsSync(filePath)) {
    try { fs.copyFileSync(filePath, `${filePath}.bak`); } catch {}
  }
  fs.writeFileSync(tmp, contents, 'utf8');
  fs.renameSync(tmp, filePath);
}

function loadDb() {
  try {
    if (!fs.existsSync(DB_PATH)) return { version: 1, works: [] };
    const raw = JSON.parse(fs.readFileSync(DB_PATH, 'utf8'));
    return raw;
  } catch {
    return { version: 1, works: [] };
  }
}
function saveDb(db) {
  fs.mkdirSync(DB_DIR, { recursive: true });
  atomicWriteFile(DB_PATH, JSON.stringify(db, null, 2));
}
function nextId(db) {
  const ids = (db.works||[]).map(w=>w.id||0);
  return (ids.length ? Math.max(...ids) : 0) + 1;
}
/* ------------------ helpers: lookup/move/flatten ------------------ */
function findById(db, id) {
  const idx = (db.works||[]).findIndex(w => Number(w.id) === Number(id));
  return { idx, work: idx >= 0 ? db.works[idx] : null };
}
function moveInArray(arr, fromIdx, toIdx) {
  if (fromIdx === toIdx) return arr;
  const a = arr.slice();
  const [item] = a.splice(fromIdx, 1);
  a.splice(toIdx, 0, item);
  return a;
}
function ensureRequired(row) {
  if (!row) return false;
  return row.title && String(row.title).trim()
      && row.slug  && String(row.slug).trim()
      && Number.isFinite(Number(row.id)) || true; // id can be absent; we’ll assign
}
function parseMaybeJSON(s) {
  if (!s || typeof s !== 'string') return null;
  try { return JSON.parse(s); } catch { return null; }
}
function normalizeImportedWork(row) {
  // Accept flexible shapes from CSV/YAML/JSON rows
  const id = Number.isFinite(Number(row.id)) ? Number(row.id) : null;
  const slug = (row.slug && String(row.slug).trim()) || slugify(row.title);
  const one = (row.one && String(row.one).trim()) || '';
  const base = {
    id: id ?? null,
    slug,
    title: String(row.title || '').trim(),
    one,
    audio: row.audio ? String(row.audio).trim() : null,
    pdf: row.pdf ? String(row.pdf).trim() : null,
    cues: Array.isArray(row.cues) ? row.cues
         : parseMaybeJSON(row.cues_json) || []
  };
  // score block via JSON or flat columns
  const scoreJSON = parseMaybeJSON(row.score_json);
  if (scoreJSON) base.score = scoreJSON;
  else if (row.pdfStartPage || row.mediaOffsetSec || row.pdfDelta || row.pageMap) {
    base.score = {
      pdfStartPage: Number(row.pdfStartPage) || 1,
      mediaOffsetSec: Number(row.mediaOffsetSec) || 0,
      ...(row.pdfDelta !== undefined ? { pdfDelta: Number(row.pdfDelta) } : {}),
      pageMap: Array.isArray(row.pageMap) ? row.pageMap : parseMaybeJSON(row.pageMap) || []
    };
  }
  return base;
}

/* ------------------ lazy external loaders ------------------ */
async function lazyCsvParse() {
  try {
    const mod = await import('csv-parse/sync');
    return mod.parse;
  } catch (e) {
    console.log(pc.red('Missing dependency "csv-parse".'));
    console.log(pc.gray('Install it with: ') + pc.cyan('npm i csv-parse'));
    process.exit(1);
  }
}
async function lazyYaml() {
  try {
    const mod = await import('yaml');
    return mod.default || mod; // ESM default export
  } catch (e) {
    console.log(pc.red('Missing dependency "yaml".'));
    console.log(pc.gray('Install it with: ') + pc.cyan('npm i yaml'));
    process.exit(1);
  }
}

/* ------------------ Config I/O ------------------ */
function loadConfig() {
  const raw = readJsonSafe(CONFIG_PATH, {});
  // deep-merge with defaults and normalize theme
  const theme = (raw.theme === 'light') ? 'light' : 'dark';
  const out   = raw.output || {};
  return {
    ...DEFAULT_CONFIG,
    theme,
    output: {
      ...DEFAULT_CONFIG.output,
      minify: !!out.minify,
      embed:  !!out.embed
    }
  };
}
function saveConfig(cfg) {
  fs.mkdirSync(CONFIG_DIR, { recursive: true });
  const normalized = {
    theme: (cfg.theme === 'light') ? 'light' : 'dark',
    output: {
      minify: !!cfg.output?.minify,
      embed:  !!cfg.output?.embed
    }
  };
  atomicWriteFile(CONFIG_PATH, JSON.stringify(normalized, null, 2));
}

/* ------------------ CLI setup ------------------ */
const pkgJson = (() => {
  try {
    const p = path.resolve(__dirname, '../../package.json');
    return JSON.parse(fs.readFileSync(p, 'utf8'));
  } catch {
    return { name: 'praetorius', version: '0.0.0' };
  }
})();

const program = new Command();
program
  .name('praetorius')
  .alias('prae')
  .description('Praetorius — Works Console scaffolder & wizard')
  .version(pkgJson.version || '0.0.0');

/* ------------------ init ------------------ */
program
  .command('init')
  .description('Create starter script + css; seed .prae/works.json + .prae/config.json if missing')
  .option('-o, --out <dir>', 'output directory', 'prae-out')
  .option('--dry-run', 'print actions without writing files', false)
  .option('-f, --force', 'overwrite if files exist', false)
  .action(async (opts) => {
    const outDir = path.resolve(process.cwd(), opts.out);
    const dry    = !!opts['dryRun'];
    const force  = !!opts.force;

    console.log(pc.bold('Praetorius init'));
    console.log(pc.gray('Target: ')+pc.cyan(cwdRel(outDir)));
    console.log(pc.gray('Mode:  ')+pc.cyan(dry ? 'dry-run' : 'write'));
    console.log(pc.gray('Force: ')+pc.cyan(force ? 'on' : 'off'));
    console.log('');

    const files = [
      { name: 'script.js',  contents: STARTER_JS },
      { name: 'styles.css', contents: STARTER_CSS },
      { name: 'README.txt', contents: STARTER_README },
    ];

    if (!dry) fs.mkdirSync(outDir, { recursive: true });

    for (const f of files) {
      const p = path.join(outDir, f.name);
      if (dry) { console.log(pc.yellow('plan  ') + pc.dim(cwdRel(p))); continue; }
      if (fs.existsSync(p) && !force) {
        console.log(pc.yellow('skip  ') + pc.dim(cwdRel(p)) + pc.gray(' (exists; use --force)'));
        continue;
      }
      fs.writeFileSync(p, f.contents, 'utf8');
      console.log(pc.green('write ') + pc.dim(cwdRel(p)));
    }

    // Seed DB if missing
    const dbExists = fs.existsSync(DB_PATH);
    if (!dry && !dbExists) {
      saveDb({ version: 1, works: [] });
      console.log(pc.green('write ') + pc.dim(cwdRel(DB_PATH)));
    }
    // Seed config if missing
    if (!dry && !fs.existsSync(CONFIG_PATH)) {
      saveConfig(DEFAULT_CONFIG);
      console.log(pc.green('write ') + pc.dim(cwdRel(CONFIG_PATH)));
    }

    console.log('\n' + pc.bold('Next steps:'));
    console.log('  • Add works: ' + pc.cyan('praetorius add'));
    console.log('  • Generate:  ' + pc.cyan('praetorius generate'));
    console.log('');
  });

/* ------------------ add / wizard ------------------ */
program
  .command('add')
  .alias('wizard')
  .description('Interactive wizard: add one or more works to .prae/works.json (IDs are identities; array order is display order)')
  .action(async () => {
    const db = loadDb();
    const ajv = new Ajv({ allErrors: true });
    const validate = ajv.compile(WORKS_SCHEMA);

    let again = true;
    while (again) {
      const base = await prompt([
        { type: 'input', name: 'title', message: 'Work title', validate: v => !!String(v).trim() || 'Required' },
        { type: 'input', name: 'slug',  message: 'Slug', initial: (ans)=> slugify(ans.title), validate: v => !!String(v).trim() || 'Required' },
        { type: 'input', name: 'one',   message: 'One-liner / description', validate: v => !!String(v).trim() || 'Required' },
        { type: 'input', name: 'audio', message: 'Audio URL (optional; leave blank if none)' },
        { type: 'input', name: 'pdf',   message: 'Score PDF URL (optional)' },
      ]);

      const cues = [];
      const wantCues = await prompt({ type: 'confirm', name: 'ok', message: 'Add cue points?', initial: true });
      if (wantCues.ok) {
        let more = true;
        while (more) {
          const c = await prompt([
            { type: 'input', name: 'label', message: 'Cue label (e.g. @5:49)', initial: '@0:00' },
            { type: 'input', name: 'time',  message: 'Cue time (mm:ss or seconds)', initial: '0:00' }
          ]);
          const t = parseTimeToSec(c.time);
          cues.push({ label: c.label || `@${c.time}`, t });
          const cont = await prompt({ type: 'confirm', name: 'ok', message: 'Add another cue?', initial: false });
          more = cont.ok;
        }
      }

      // NEW: page-follow (score) block
      let score = null;
      const wantScore = await prompt({ type: 'confirm', name: 'ok', message: 'Add PDF page-follow mapping for this work?', initial: false });
      if (wantScore.ok) {
        const sBase = await prompt([
          { type: 'input', name: 'pdfStartPage',   message: 'Printed p.1 equals PDF page (pdfStartPage)', initial: '1', validate: v => /^\d+$/.test(String(v).trim()) && parseInt(v,10)>=1 ? true : 'Enter an integer ≥ 1' },
          { type: 'input', name: 'mediaOffsetSec', message: 'Media offset seconds (can be negative, default 0)', initial: '0', validate: v => /^-?\d+$/.test(String(v).trim()) ? true : 'Enter an integer (e.g., 0, -30, 12)' },
        ]);

        const pageMap = [];
        let more = true;
        while (more) {
          const pm = await prompt([
            { type: 'input', name: 'at',   message: 'Time (mm:ss or seconds)', initial: pageMap.length ? '' : '0:00', validate: v => String(v).trim().length ? true : 'Required' },
            { type: 'input', name: 'page', message: 'Printed page number', initial: pageMap.length ? '' : '1', validate: v => /^\d+$/.test(String(v).trim()) && parseInt(v,10)>=1 ? true : 'Enter an integer ≥ 1' }
          ]);
          pageMap.push({ at: pm.at.trim(), page: parseInt(pm.page,10) });
          const cont = await prompt({ type: 'confirm', name: 'ok', message: 'Add another page mapping?', initial: false });
          more = cont.ok;
        }

        // Optional: pdfDelta tweak
        let pdfDeltaVal = null;
        const wantDelta = await prompt({ type: 'confirm', name: 'ok', message: 'Add optional pdfDelta (advanced)?', initial: false });
        if (wantDelta.ok) {
          const dAns = await prompt([{ type: 'input', name: 'pdfDelta', message: 'pdfDelta (integer; default none)', validate: v => /^-?\d+$/.test(String(v).trim()) ? true : 'Enter an integer' }]);
          pdfDeltaVal = parseInt(dAns.pdfDelta, 10);
        }

        score = {
          pdfStartPage: parseInt(sBase.pdfStartPage,10),
          mediaOffsetSec: parseInt(sBase.mediaOffsetSec,10),
          pageMap
        };
        if (Number.isInteger(pdfDeltaVal)) score.pdfDelta = pdfDeltaVal;
      }

      const entry = {
        id: nextId(db),
        slug: base.slug,
        title: base.title,
        one: base.one,
        audio: base.audio?.trim() || null,
        pdf: base.pdf?.trim() || null,
        cues
      };
      if (score) entry.score = score;

      const candidate = { version: db.version || 1, works: [...db.works, entry] };
      const ok = validate(candidate);
      if (!ok) {
        console.log(pc.red('Validation failed:'));
        for (const e of validate.errors || []) {
          console.log('  - ' + e.instancePath + ' ' + e.message);
        }
        const retry = await prompt({ type: 'confirm', name: 'ok', message: 'Edit and try again?', initial: true });
        if (!retry.ok) break;
        continue;
      }

      saveDb(candidate);
      console.log(pc.green('added ') + pc.dim(`#${entry.id} ${entry.title}`));

      const cont = await prompt({ type: 'confirm', name: 'ok', message: 'Add another work?', initial: true });
      again = cont.ok;
    }

    console.log(pc.gray('DB at ') + pc.cyan(cwdRel(DB_PATH)));
  });

/* ------------------ list ------------------ */
program
  .command('list')
  .description('List works from .prae/works.json')
  .action(() => {
    const db = loadDb();
    if (!db.works.length) { console.log(pc.yellow('No works yet. Add with: ') + pc.cyan('praetorius add')); return; }
    console.log(pc.bold('Works'));
   db.works.forEach((w, idx) => {
      console.log(pc.cyan(`#${w.id}`) + ' ' + w.title + pc.gray(`  (${w.slug})`));
     console.log('   ' + pc.dim(w.one) + pc.gray(`   [order=${idx+1}]`));
      if (w.audio) console.log('   audio: ' + pc.gray(w.audio));
      if (w.pdf)   console.log('   pdf:   ' + pc.gray(w.pdf));
      if (w.cues?.length) {
        const cs = w.cues.map(c => `${c.label}=${c.t}s`).join(', ');
        console.log('   cues:  ' + pc.gray(cs));
      }
      if (w.score?.pageMap?.length) {
        console.log('   score: ' + pc.gray(`p1→PDF ${w.score.pdfStartPage ?? 1}, offset ${w.score.mediaOffsetSec ?? 0}s, map ${w.score.pageMap.length} rows`));
      }
    });
  });

/* ------------------ edit ------------------ */
program
  .command('edit <id>')
  .description('Edit a work (wizard by default; flags to set fields directly)')
  .option('--title <str>', 'Set title')
  .option('--slug <str>',  'Set slug')
  .option('--one <str>',   'Set one-liner')
  .option('--audio <url>', 'Set audio URL (or empty to clear)')
  .option('--pdf <url>',   'Set score PDF URL (or empty to clear)')
  .option('--no-cues',     'Do not edit cues interactively')
  .option('--no-score',    'Do not edit score/page-follow interactively')
  .action(async (id, opts) => {
    const db = loadDb();
    const { idx, work } = findById(db, id);
    if (idx < 0) { console.log(pc.red(`No work with id ${id}`)); process.exit(1); }

    // Apply direct flags first (non-interactive)
    if (opts.title) work.title = opts.title;
    if (opts.slug)  work.slug  = opts.slug;
    if (opts.one)   work.one   = opts.one;
    if ('audio' in opts) work.audio = (opts.audio === '' ? null : opts.audio);
    if ('pdf'   in opts) work.pdf   = (opts.pdf   === '' ? null : opts.pdf);

    // If no flags changed anything, run wizard
    const changedViaFlags =
      !!(opts.title || opts.slug || opts.one || 'audio' in opts || 'pdf' in opts);
    if (!changedViaFlags) {
      const base = await prompt([
        { type: 'input', name: 'title', message: 'Title', initial: work.title },
        { type: 'input', name: 'slug',  message: 'Slug',  initial: work.slug },
        { type: 'input', name: 'one',   message: 'One-liner', initial: work.one },
        { type: 'input', name: 'audio', message: 'Audio URL (blank to clear)', initial: work.audio || '' },
        { type: 'input', name: 'pdf',   message: 'Score PDF URL (blank to clear)', initial: work.pdf || '' }
      ]);
      work.title = base.title.trim();
      work.slug  = base.slug.trim();
      work.one   = base.one.trim();
      work.audio = base.audio.trim() || null;
      work.pdf   = base.pdf.trim()   || null;
    }

    // Cues edit (unless --no-cues)
    if (opts.cues !== false) {
      const ans = await prompt({ type: 'confirm', name: 'ok', message: 'Edit cues?', initial: false });
      if (ans.ok) {
        const newCues = [];
        let more = true;
        while (more) {
          const c = await prompt([
            { type: 'input', name: 'label', message: 'Cue label', initial: '@0:00' },
            { type: 'input', name: 'time',  message: 'mm:ss or seconds', initial: '0:00' }
          ]);
          newCues.push({ label: c.label || `@${c.time}`, t: parseTimeToSec(c.time) });
          const cont = await prompt({ type: 'confirm', name: 'ok', message: 'Add another cue?', initial: false });
          more = cont.ok;
        }
        work.cues = newCues;
      }
    }

    // Score/page-follow edit (unless --no-score)
    if (opts.score !== false) {
      const ans = await prompt({ type: 'confirm', name: 'ok', message: 'Edit page-follow (score)?', initial: false });
      if (ans.ok) {
        const s0 = work.score || { pdfStartPage: 1, mediaOffsetSec: 0, pageMap: [] };
        const sBase = await prompt([
          { type: 'input', name: 'pdfStartPage',   message: 'Printed p.1 equals PDF page', initial: String(s0.pdfStartPage ?? 1), validate: v => /^\d+$/.test(String(v).trim()) && parseInt(v,10)>=1 ? true : 'Enter an integer ≥ 1' },
          { type: 'input', name: 'mediaOffsetSec', message: 'Media offset seconds (can be negative)', initial: String(s0.mediaOffsetSec ?? 0), validate: v => /^-?\d+$/.test(String(v).trim()) ? true : 'Enter an integer' }
        ]);
        const pm = [];
        let more = true;
        while (more) {
          const row = await prompt([
            { type: 'input', name: 'at',   message: 'Time (mm:ss or seconds)', initial: pm.length ? '' : '0:00', validate: v => String(v).trim().length ? true : 'Required' },
            { type: 'input', name: 'page', message: 'Printed page number',     initial: pm.length ? '' : '1',    validate: v => /^\d+$/.test(String(v).trim()) && parseInt(v,10)>=1 ? true : 'Enter integer ≥ 1' }
          ]);
          pm.push({ at: row.at.trim(), page: parseInt(row.page, 10) });
          const cont = await prompt({ type: 'confirm', name: 'ok', message: 'Add another page mapping?', initial: false });
          more = cont.ok;
        }
        work.score = {
          pdfStartPage: parseInt(sBase.pdfStartPage,10),
          mediaOffsetSec: parseInt(sBase.mediaOffsetSec,10),
          pageMap: pm
        };
      }
    }

    // Save
    const ajv = new Ajv({ allErrors: true });
    const validate = ajv.compile(WORKS_SCHEMA);
    const candidate = { ...db };
    candidate.works[idx] = work;
    if (!validate(candidate)) {
      console.log(pc.red('Validation failed:'));
      for (const e of validate.errors || []) console.log('  - ' + (e.instancePath||'/') + ' ' + e.message);
      process.exit(1);
    }
    saveDb(candidate);
    console.log(pc.green('updated ') + pc.dim(`#${work.id} ${work.title}`));
  });

/* ------------------ rm ------------------ */
program
  .command('rm <id>')
  .description('Remove a work by id (confirms; .bak kept automatically)')
  .action(async (id) => {
    const db = loadDb();
    const { idx, work } = findById(db, id);
    if (idx < 0) { console.log(pc.red(`No work with id ${id}`)); process.exit(1); }
    const ans = await prompt({ type: 'confirm', name: 'ok', message: `Delete #${work.id} ${work.title}?`, initial: false });
    if (!ans.ok) { console.log(pc.gray('aborted')); return; }
    const next = { ...db, works: db.works.filter((_, i) => i !== idx) };
    saveDb(next);
    console.log(pc.green('removed ') + pc.dim(`#${work.id} ${work.title}`));
  });

/* ------------------ order ------------------ */
program
  .command('order')
  .description('Reorder works (interactive by default). Use --move <id> --to <index> for direct move.')
  .option('--move <id>', 'Move a single id')
  .option('--to <index>', 'Target 1-based index for --move')
  .action(async (opts) => {
    const db = loadDb();
    if (!db.works.length) { console.log(pc.yellow('No works to reorder.')); return; }
    if (opts.move && !opts.to) { console.log(pc.red('Provide --to <index> with --move.')); process.exit(1); }

    if (opts.move && opts.to) {
      const id = Number(opts.move);
      const target = Number(opts.to) - 1; // 1-based → 0-based
      const { idx } = findById(db, id);
      if (idx < 0) { console.log(pc.red(`No work with id ${id}`)); process.exit(1); }
      if (target < 0 || target >= db.works.length) { console.log(pc.red('Index out of range.')); process.exit(1); }
      const next = { ...db, works: moveInArray(db.works, idx, target) };
      saveDb(next);
      console.log(pc.green('moved ') + pc.dim(`#${id} → position ${target+1}`));
      return;
    }

    console.log(pc.bold('Current order:'));
    db.works.forEach((w,i)=>console.log(`${String(i+1).padStart(2,' ')}. #${w.id} ${w.title}`));
    const ans = await prompt({
      type: 'input',
      name: 'order',
      message: 'Enter new order as space/comma-separated IDs (e.g., "3 1 2"):',
    });
    const tokens = String(ans.order||'').split(/[,\s]+/).filter(Boolean).map(n=>Number(n));
    const idsNow = db.works.map(w=>w.id);
    const sameSet = tokens.length === idsNow.length && tokens.every(id => idsNow.includes(id));
    if (!sameSet) { console.log(pc.red('New order must contain exactly the same IDs.')); process.exit(1); }
    const byId = new Map(db.works.map(w => [w.id, w]));
    const reordered = tokens.map(id => byId.get(id));
    saveDb({ ...db, works: reordered });
    console.log(pc.green('reordered ') + pc.dim(tokens.join(' ')));
  });

/* ------------------ import ------------------ */
program
  .command('import <file>')
  .description('Import works from JSON|CSV|YAML and merge into DB (prompts to resolve conflicts).')
  .option('--assume-new-id', 'On id conflict, auto-assign next id (skip prompt)', false)
  .option('--assume-new-slug', 'On slug conflict, auto-append suffix (skip prompt)', false)
  .action(async (file, opts) => {
    const db = loadDb();
    const ext = path.extname(file).toLowerCase();
    const buf = fs.readFileSync(file, 'utf8');
    let rows = [];

    if (ext === '.json') {
      const YAML = await lazyYaml();
      const obj = YAML.parse(buf);
      rows = Array.isArray(obj) ? obj : (Array.isArray(obj.works) ? obj.works : []);
    } else if (ext === '.yaml' || ext === '.yml') {
      const obj = YAML.parse(buf);
      rows = Array.isArray(obj) ? obj : (Array.isArray(obj.works) ? obj.works : []);
    } else if (ext === '.csv') {
const parseCSV = await lazyCsvParse();
      const recs = parseCSV(buf, { columns: true, skip_empty_lines: true });
      rows = recs;
    } else {
      console.log(pc.red('Unsupported format. Use .json, .csv, .yaml/.yml'));
      process.exit(1);
    }

    if (!rows.length) { console.log(pc.yellow('No rows to import.')); return; }

    const incoming = [];
    for (const r of rows) {
      if (!ensureRequired(r) && !(r.title && r.slug && r.one)) {
        console.log(pc.yellow('skip row (missing required fields): ') + pc.dim(JSON.stringify(r)));
        continue;
      }
     incoming.push(normalizeImportedWork(r));
    }

    // Merge with conflict handling
    const byId    = new Map((db.works||[]).map(w => [Number(w.id), w]));
    const bySlug  = new Map((db.works||[]).map(w => [String(w.slug), w]));
    const merged  = db.works ? db.works.slice() : [];

    for (const w of incoming) {
      // id resolution
      let id = w.id;
      if (id === null) id = nextId({ works: merged });
      if (byId.has(id)) {
        if (opts.assume_new_id) {
          id = nextId({ works: merged });
        } else {
          const choice = await prompt({
            type: 'select', name: 'act', message: `ID ${id} exists. How to import "${w.title}"?`,
            choices: [
              { name: 'overwrite', message: 'Overwrite existing by id' },
              { name: 'newid',     message: 'Assign new id' },
              { name: 'skip',      message: 'Skip this row' }
            ]
          });
          if (choice.act === 'skip') continue;
          if (choice.act === 'newid') id = nextId({ works: merged });
          if (choice.act === 'overwrite') {
            const overwriteIdx = merged.findIndex(x => Number(x.id) === Number(id));
            const newWork = { ...w, id };
            merged[overwriteIdx] = newWork;
            // update slug map
            bySlug.set(newWork.slug, newWork);
            byId.set(id, newWork);
            continue;
          }
        }
      }

      // slug resolution
      let slug = String(w.slug);
      if (bySlug.has(slug)) {
        if (opts.assume_new_slug) {
          let n = 2;
          while (bySlug.has(`${slug}-${n}`)) n++;
          slug = `${slug}-${n}`;
        } else {
          const choice = await prompt({
            type: 'select', name: 'act', message: `Slug "${slug}" exists. Import "${w.title}" as…`,
            choices: [
              { name: 'newslug',  message: 'Append numeric suffix' },
              { name: 'overwrite', message: 'Overwrite existing by slug' },
              { name: 'skip',      message: 'Skip this row' }
            ]
          });
          if (choice.act === 'skip') continue;
          if (choice.act === 'newslug') {
            let n = 2;
            while (bySlug.has(`${slug}-${n}`)) n++;
            slug = `${slug}-${n}`;
          }
          if (choice.act === 'overwrite') {
            const overwriteIdx = merged.findIndex(x => String(x.slug) === String(slug));
            const newWork = { ...w, id, slug };
            merged[overwriteIdx] = newWork;
            bySlug.set(slug, newWork);
            byId.set(id, newWork);
            continue;
          }
        }
      }

      const newWork = { ...w, id, slug };
      merged.push(newWork);
      byId.set(id, newWork);
      bySlug.set(slug, newWork);
    }

    // Validate + save
    const ajv = new Ajv({ allErrors: true });
    const validate = ajv.compile(WORKS_SCHEMA);
    const candidate = { version: db.version || 1, works: merged };
    if (!validate(candidate)) {
      console.log(pc.red('Post-import validation failed:'));
      for (const e of validate.errors || []) console.log('  - ' + (e.instancePath||'/') + ' ' + e.message);
      process.exit(1);
    }
    saveDb(candidate);
    console.log(pc.green('imported ') + pc.dim(`${incoming.length} row(s)`));
  });

/* ------------------ export ------------------ */
program
  .command('export')
  .description('Export DB to stdout as JSON or CSV')
  .option('--format <fmt>', 'json|csv', 'json')
  .action((opts) => {
    const db = loadDb();
    const fmt = String(opts.format||'json').toLowerCase();
    if (fmt === 'json') {
      process.stdout.write(JSON.stringify(db, null, 2) + '\n');
      return;
    }
    if (fmt === 'csv') {
      // Stable columns; JSON-encode nested
      const cols = ['id','slug','title','one','audio','pdf','cues_json','score_json'];
      const lines = [];
      lines.push(cols.join(','));
      for (const w of db.works||[]) {
        const row = [
          w.id ?? '',
          (w.slug ?? '').replaceAll('"','""'),
          (w.title ?? '').replaceAll('"','""'),
          (w.one ?? '').replaceAll('"','""'),
          (w.audio ?? '').replaceAll('"','""'),
          (w.pdf ?? '').replaceAll('"','""'),
          JSON.stringify(w.cues ?? []).replaceAll('"','""'),
          JSON.stringify(w.score ?? null).replaceAll('"','""'),
        ].map(v => `"${String(v)}"`);
        lines.push(row.join(','));
      }
      process.stdout.write(lines.join('\n') + '\n');
      return;
    }
    console.log(pc.red('Unknown format; use --format=json|csv'));
    process.exit(1);
  });

/* ------------------ doctor ------------------ */
program
  .command('doctor')
  .description('Validate DB + config; check duplicate IDs/slugs. Exit code 0=ok, 1=problems.')
  .option('--json', 'machine-readable JSON report', false)
  .option('-q, --quiet', 'suppress OK chatter; only errors', false)
  .action((opts) => {
    const db  = loadDb();
    const cfg = loadConfig();
    const ajv = new Ajv({ allErrors: true });
    const validate = ajv.compile(WORKS_SCHEMA);
    const errors = [];

    if (!validate(db)) {
      for (const e of validate.errors || []) {
        errors.push({ type: 'schema', where: e.instancePath || '/', msg: e.message || 'invalid' });
      }
    }
    // duplicate ID/slug checks
    const idSeen = new Set(), slugSeen = new Set();
    const dupIds = new Set(), dupSlugs = new Set();
    for (const w of db.works || []) {
      if (idSeen.has(w.id)) dupIds.add(w.id); else idSeen.add(w.id);
      if (slugSeen.has(w.slug)) dupSlugs.add(w.slug); else slugSeen.add(w.slug);
    }
    if (dupIds.size)  errors.push({ type: 'duplicate', where: 'id',   msg: `duplicate ids: ${[...dupIds].join(', ')}` });
    if (dupSlugs.size)errors.push({ type: 'duplicate', where: 'slug', msg: `duplicate slugs: ${[...dupSlugs].join(', ')}` });

    // config validation (theme only)
    if (!(cfg.theme === 'light' || cfg.theme === 'dark')) {
      errors.push({ type: 'config', where: 'theme', msg: 'theme must be "light" or "dark"' });
    }

    const ok = errors.length === 0;
    if (opts.json) {
      const report = { ok, errors, counts: { works: db.works?.length || 0 } };
      console.log(JSON.stringify(report, null, 2));
    } else {
      if (ok && !opts.quiet) {
        console.log(pc.green('doctor: OK'));
        console.log(pc.gray(`works: ${db.works?.length || 0}, theme: ${cfg.theme}, minify:${cfg.output.minify}, embed:${cfg.output.embed}`));
      } else if (!ok) {
        console.log(pc.red('doctor: issues found'));
        errors.forEach(e => console.log(`  - ${e.type} ${pc.gray(e.where)}: ${e.msg}`));
      }
    }
    process.exit(ok ? 0 : 1);
  });

/* ------------------ generate ------------------ */
program
  .command('generate')
  .alias('build')
  .description('Emit dist/script.js and dist/styles.css from .prae/works.json (respects .prae/config.json)')
  .option('-o, --out <dir>', 'output directory', 'dist')
  .option('--no-css', 'skip writing styles.css')
  .action(async (opts) => {
    const outDir = path.resolve(process.cwd(), opts.out);
    const db = loadDb();
    const cfg = loadConfig();
    fs.mkdirSync(outDir, { recursive: true });

    // Basic validation
    const ajv = new Ajv({ allErrors: true });
    const validate = ajv.compile(WORKS_SCHEMA);
    if (!validate(db)) {
      console.log(pc.red('DB validation failed:'));
      for (const e of validate.errors || []) console.log('  - ' + e.instancePath + ' ' + e.message);
      process.exit(1);
    }

    // Render script (now includes pageFollowMaps). Respect minify flag for JSON payloads.
    const js = renderScriptFromDb(db, { minify: !!cfg.output.minify, theme: cfg.theme });
    const jsPath = path.join(outDir, 'script.js');
    // atomic write for generated assets too (safe on replace)
    atomicWriteFile(jsPath, js);
    console.log(pc.green('write ') + pc.dim(cwdRel(jsPath)));

    // CSS (optional)
    if (opts.css) {
      const cssPath = path.join(outDir, 'styles.css');
      if (!fs.existsSync(cssPath)) {
        fs.writeFileSync(cssPath, STARTER_CSS, 'utf8');
        console.log(pc.green('write ') + pc.dim(cwdRel(cssPath)));
      } else {
        console.log(pc.yellow('skip  ') + pc.dim(cwdRel(cssPath)) + pc.gray(' (exists)'));
      }
    }

    console.log('\n' + pc.bold('Next steps:'));
    console.log('  • Paste ' + pc.cyan(cwdRel(jsPath)) + ' into your Squarespace code block (or host it).');
    console.log('  • Add   ' + pc.cyan('styles.css') + ' to page/site CSS (if not already).');
    console.log(pc.gray('  • Ensure your main.js uses: const pageFollowMaps = (window.PRAE && window.PRAE.pageFollowMaps) || { /* fallback */ };'));
  });

/* ------------------ run ------------------ */
program.parseAsync(process.argv);
